# Лабораторная работа №2. Ручное построение нисходящих синтаксических анализаторов

   Main классом является [App](src/main/kotlin/ru/itmo/chizhikov/App.kt). На вход парсер получает строку, после обработки которой выводит дерево на языке [DOT](https://en.wikipedia.org/wiki/DOT_(graph_description_language)). При наличии второго аргумента парсер создаст svg-изображение([Пример](example.svg)) дерева с именем равным этому аргументу. 
Входные данные могут быть введены как с консоли, так и в качестве аргументов программы. При желании можно собрать парсер в jar с помощью gradle.


### Вариант 9. Описание массивов в Паскале

Массив в паскале. Заголовок начинается ключевым словом “**var**”, далее идет имя массива, двоеточие, ключевое слово
 “**array**”, далее описание диапазона индексов, затем “**of**” и имя типа. Диапазон индексов представляет собой две 
 границы, между которыми две точки.
 
Используйте один терминал для всех имен переменных и имен типов. Используйте один терминал для ключевого слов **var** 
и **array** (не несколько ‘**v**’, ‘**a**’, ‘**r**’).

Пример:
 ```Pascal
var x: array [1..10] of integer;
```

## Грамматика

Примитивная - в данной грамматике допускаются пробелы в любой части между токенами(хотя в Pascal это не так), для исключения подобного можно ввести новый токен WHITESPACE, который будет означать 1 или более проблельных символов и сделать там, где это нужно правила строгими относительно пробелов:

| Нетерминал                 | Описание                                                                                                                                                                                                                             |
|----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `S -> V X : A [D] O T;`    | Массив в Pascal состоит из V - "var", X - имени массива, далее ":" и A - "array", D - диапазона значений индексов, заключенного в квадратные скобки, O - "of" и T - типа элементов данного массива, в конце заканичивается на ";".   |
|  `D -> D,D or R`           | Т.к. массив может быть _n_ - мерным, то каждый из диапазонов может состоять из двух, разделененных "," или же являеться одним промежутком R.                                                                                         |
| `R -> N..N`                | Промежуток состоит из двух N - number или же чисел, разеделенных двумя точками.                                                                                                                                                      |                                                                                                                                                                                            |
|  `X -> X,X or id`          | Объявление массивов может состоять из одного или нескольких имен, имя каждого - идентификатор                                                                                                                                        |
| `T -> id`                  | По условию для имен массивов и имен типов используется один терминал - идентификатор                                                                                                                                                 |
| `N -> number`              | Число имеет же свой идентификатор, чтобы отличаться от имён                                                                                                                                                                          |                                                                                                                                                                                        |

Напомню, что для построения нисходящего парсера без возврата нужна [`LL(1)`-грамматика](https://neerc.ifmo.ru/wiki/index.php?title=LL(k)-%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B8,_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0_FIRST_%D0%B8_FOLLOW).
Грамматика имеющая левую рекурсию и правое ветвления не является `LL(1)`. В этой грамматике из-за правил D и X имеется левая рекурсия и правое ветвление - устраним их, используя алгоритмы устранения [левой рекурсии](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A3%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BB%D0%B5%D0%B2%D0%BE%D0%B9_%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B8) и [правого ветвления](https://neerc.ifmo.ru/wiki/index.php?title=LL(k)-%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B8,_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0_FIRST_%D0%B8_FOLLOW#defLLK):

| Нетерминал              | Описание                                                                                 |
|-------------------------|------------------------------------------------------------------------------------------|
| `S  -> V X : A [D] O T;`| Описание массива в Pascal как выше.                                                      |
| `D  -> RD''`            | Описание списка диапазонов размерностей.                                                 |
| `R  -> N..N`            | Описание промежутка одной размерности                                                    |
| `D''-> D'`              | Продолжение списка размерностей                                                          |
| `D''-> ε`               | Конец списка размерностей                                                                |
| `D' -> ,DP`             | Описание нового диапазона размерности                                                    |
| `P  -> D'`              | Продолжение нового диапазона                                                             |
| `P  -> ε `              | Конец списка                                                                             |
| `X  -> idX''`           | Описание списка имен массивов                                                            |                                                                            |
| `X''-> X'`              | Продолжение списка имен массивов                                                         |
| `X''-> ε`               | Конец списка имен массивов                                                               |
| `X' -> ,XY`             | Описание нового имени элемента в списке имен                                             |
| `Y  -> X'`              | Новый элемент списка имен                                                                |
| `Y  -> ε`               | Конец списка имен                                                                        |
| `T  -> id`              | Тип элементов массива                                                                    |
| `N  -> number`          | Число для описания значений размерностей массива                                         |

## Терминалы

| Терминал  | Токен      |
|-----------|------------|
| `<id>`    | ID         |
| `<number>`| NUMBER     |
| `..`      | DOUBLEDOT  |
| `,`       | COMMA      |
| `:`       | DOUBLECOLON|
| `;`       | SEMICOLON  |  
| `[`       | OPEN_QBR   |
| `]`       | CLOSE_QBR  |
| `array`   | ARRAY      |
|  `var`    | VAR        |
|  `of`     | OF         |
|  `ε`      | EPS        |
|  `$`      | EOF        |

[Lexer для получения токенов](src/main/kotlin/ru/itmo/chizhikov/Lexer.kt)

## First and Follow

Построим мн-ва [First и Follow](https://neerc.ifmo.ru/wiki/index.php?title=LL(k)-%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B8,_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0_FIRST_%D0%B8_FOLLOW#defLLK), используя [алгоритмы построения](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5_FIRST_%D0%B8_FOLLOW):

|      | FIRST     | FOLLOW     |
|------|-----------|------------|
| `S`  | `var`     | `$`        |
| `D`  | `n`       | `]`,`,`    |
| `D''`| `ε`,`,`   | `]`,`,`    |
| `R`  | `n`       | `,`,`]`    |
| `D'` | `,`       | `]`,`,`    |
| `P`  | `ε`,`,`   | `]`,`,`    |
| `X`  | `<id>`    | `:`,`,`    |
| `X''`| `ε`,`,`   | `:`,`,`    |
| `X'` | `,`       | `:`,`,`    |
| `Y`  | `ε`,`,`   |  `:`,`,`   |
| `T`  | `<id>`    | `;`        |
| `N`  | `<number>`| `.`,`,`,`]`|

Теперь, используя эти множества построим синтаксических анализатор или же парсер:

[Parser](src/main/kotlin/ru/itmo/chizhikov/Parser.kt)

Также приведу набор тестов(используется библиотека [JUnit](https://junit.org/junit5/)):

[Тесты для Lexer](src/test/kotlin/ru/itmo/chizhikov/LexerTest.kt)
[Тесты для Parser](src/test/kotlin/ru/itmo/chizhikov/ParserTest.kt)
